{
  "version": 3,
  "sources": ["../node_modules/@nureon22/ripple-effect/src/main.js", "../src/components/base.ts", "../src/components/button/button.ts", "../src/components/switch/switch.ts", "../src/main.ts"],
  "sourcesContent": ["const uniqueID = (() => {\n  return String(Math.random()).slice(2);\n})();\n\nasync function waitAnimationFrame() {\n  return new Promise((resolve) => {\n    window.requestAnimationFrame(resolve);\n  });\n}\n\n/**\n * @param {HTMLElement} element\n * @param {{ [key: string]: string }} properties\n */\nfunction setCSSProperties(element, properties) {\n  for (let key in properties) {\n    element.style.setProperty(key, properties[key]);\n  }\n}\n\n/**\n * @typedef RippleEffectOptions\n * @prop {string} [color] Default \"currentColor\"\n * @prop {number} [hoveredOpacity] Opacity for hovered layer. Default 0.08\n * @prop {number} [focusedOpacity] Opacity for focused layer. Default 0.08\n * @prop {number} [pressedOpacity] Opacity for pressed layer. Default 0.12\n * @prop {number} [duration] ripple effect animation duration in milliseconds. Default 400.\n * @prop {string} [easing] ripple effect animation timing function Default ease-in.\n * @prop {number} [exitdelay] ripple effect exit delay in milliseconds. Default 0.\n * @prop {boolean} [unbounded] If true, the ripple effect overflow will be visible. Default false,\n * @prop {boolean} [autoexit] If true, the ripple effect wouldn't exit until mouseup or touchend event. Default true.\n * @prop {boolean} [rounded] If true, the ripple effect boundary will become perfect circle.\n * @prop {boolean} [centered] If true, the ripple effect will always be triggered from center of target element instead of touched position.\n * @prop {boolean} [keydown] If true, the ripple effect will be triggered by keydown event. Default true\n * @prop {HTMLElement} [trigger] Set different trigger element, by default trigger element is same as target\n */\n\nexport default class RippleEffect {\n  /** @type {(() => void)[]} */\n  _destroy_tasks = [];\n\n  /** @type {Document} **/\n  document;\n\n  /** @type {RippleEffectOptions} */\n  options;\n\n  /**\n   * @param {HTMLElement} target\n   * @param {?RippleEffectOptions=} [options]\n   */\n  constructor(target, options) {\n    if (!(target instanceof HTMLElement)) {\n      throw new TypeError(\"Argument 1 must be instanceof HTMLElement\");\n    }\n\n    this.target = target;\n    this.document = this.target.ownerDocument;\n    this.options = {\n      trigger: target,\n      ...RippleEffect.defaultOptions,\n      ...options,\n    };\n\n    this.wrapper = this.document.createElement(\"span\");\n    setCSSProperties(this.wrapper, {\n      \"display\": \"block\",\n      \"position\": \"absolute\",\n      \"top\": \"0px\",\n      \"right\": \"0px\",\n      \"bottom\": \"0px\",\n      \"left\": \"0px\",\n      \"border-radius\": this.options.rounded ? \"50%\" : \"inherit\",\n      \"color\": this.options.color || \"currentColor\",\n      \"overflow\": this.options.unbounded ? \"visible\" : \"hidden\",\n      \"pointer-events\": \"none\",\n    });\n    this.target.prepend(this.wrapper);\n\n    const hoveredAndFocusedLayerStyles = {\n      \"display\": \"block\",\n      \"position\": \"absolute\",\n      \"top\": \"0px\",\n      \"right\": \"0px\",\n      \"bottom\": \"0px\",\n      \"left\": \"0px\",\n      \"background-color\": \"currentColor\",\n      \"opacity\": \"0\",\n      \"transition\": `opacity ${this.options.duration / 2}ms ${this.options.easing} 0ms`,\n    };\n\n    this.focusedLayer = this.document.createElement(\"span\");\n    setCSSProperties(this.focusedLayer, hoveredAndFocusedLayerStyles);\n    this.wrapper.prepend(this.focusedLayer);\n\n    this.hoveredLayer = this.document.createElement(\"span\");\n    setCSSProperties(this.hoveredLayer, hoveredAndFocusedLayerStyles);\n    this.wrapper.prepend(this.hoveredLayer);\n\n    let targetCSSPosition = getComputedStyle(this.target).getPropertyValue(\n      \"position\",\n    );\n    if (targetCSSPosition != \"relative\" && targetCSSPosition != \"absolute\") {\n      this.target.style.position = \"relative\";\n    }\n\n    /**\n     * @param {KeyboardEvent} event\n     */\n    const onKeyDown = (event) => {\n      if (event.key != \" \") {\n        return;\n      }\n\n      let pressing = true;\n      let x, y;\n\n      const rect = this.wrapper.getBoundingClientRect();\n\n      x = rect.width / 2;\n      y = rect.height / 2;\n\n      if (this.options.autoexit) {\n        /** @type {() => void} */\n        let exit;\n\n        this.trigger(x, y, (e) => {\n          exit = e;\n          !pressing && exit();\n        });\n        window.addEventListener(\n          \"keyup\",\n          () => {\n            pressing = false;\n            exit && exit();\n          },\n          { once: true },\n        );\n      } else {\n        this.trigger(x, y);\n      }\n    };\n\n    /**\n     * @param {MouseEvent | TouchEvent} event\n     */\n    const onTouch = (event) => {\n      const isMouseEvent = event instanceof MouseEvent;\n\n      // prevent mouse event in touchscreen devices\n      if (isMouseEvent && isTouchscreen) return;\n\n      let pressing = true;\n      let x, y;\n\n      const rect = this.wrapper.getBoundingClientRect();\n\n      if (this.options.centered) {\n        x = rect.width / 2;\n        y = rect.height / 2;\n      } else if (isMouseEvent) {\n        x = event.x - rect.x;\n        y = event.y - rect.y;\n      } else {\n        x = event.targetTouches[0].clientX - rect.x;\n        y = event.targetTouches[0].clientY - rect.y;\n      }\n\n      if (this.options.autoexit) {\n        /** @type {() => void} */\n        let exit;\n\n        this.trigger(x, y, (e) => {\n          exit = e;\n          !pressing && exit();\n        });\n        window.addEventListener(\n          \"mouseup\",\n          () => {\n            !isTouchscreen && ((pressing = false), exit && exit());\n          },\n          { once: true },\n        );\n        window.addEventListener(\n          \"touchend\",\n          () => {\n            pressing = false;\n            exit && exit();\n          },\n          { once: true },\n        );\n      } else {\n        this.trigger(x, y);\n      }\n    };\n\n    /**\n     * @param {MouseEvent} event\n     */\n    const onHover = (event) => {\n      const isHovered = event.type == \"mouseenter\";\n\n      this.hoveredLayer.style.opacity = String(\n        isHovered ? this.options.hoveredOpacity : 0,\n      );\n    };\n\n    /**\n     * @param {FocusEvent} event\n     */\n    const onFocusChange = (event) => {\n      const isFocused = event.type == \"focus\";\n\n      this.focusedLayer.style.opacity = String(\n        isFocused ? this.options.focusedOpacity : 0,\n      );\n    };\n\n    const trigger = this.options.trigger ?? this.target;\n\n    if (this.options.keydown) {\n      trigger.addEventListener(\"keydown\", onKeyDown);\n    }\n\n    trigger.addEventListener(\"mousedown\", onTouch);\n    trigger.addEventListener(\"touchstart\", onTouch);\n\n    trigger.addEventListener(\"mouseenter\", onHover);\n    trigger.addEventListener(\"mouseleave\", onHover);\n\n    trigger.addEventListener(\"focus\", onFocusChange);\n    trigger.addEventListener(\"blur\", onFocusChange);\n\n    this._destroy_tasks.push(() => {\n      if (this.options.keydown) {\n        trigger.removeEventListener(\"keydown\", onKeyDown);\n      }\n\n      trigger.removeEventListener(\"mousedown\", onTouch);\n      trigger.removeEventListener(\"touchstart\", onTouch);\n\n      trigger.removeEventListener(\"mouseenter\", onHover);\n      trigger.removeEventListener(\"mouseleave\", onHover);\n\n      trigger.removeEventListener(\"focus\", onFocusChange);\n      trigger.removeEventListener(\"blur\", onFocusChange);\n    });\n    this._destroy_tasks.push(() => {\n      this.wrapper.remove();\n    });\n  }\n\n  /**\n   * Trigger a new ripple effect\n   * @param {number} x\n   * @param {number} y\n   * @param {((exit: () => void) => void)} [exitFn] If exitFn is given, the created ripple effect will not exit even after enter animation is finished. You need to call the exit function passed to exitFn as a first argument.\n   */\n  async trigger(x, y, exitFn) {\n    if (Number.isNaN(x))\n      throw new TypeError(\"Argument 1 must be a valid number\");\n    if (Number.isNaN(y))\n      throw new TypeError(\"Argument 2 must be a valid number\");\n\n    const rect = this.wrapper.getBoundingClientRect();\n    const size =\n      Math.hypot(Math.max(x, rect.width - x), Math.max(y, rect.height - y)) * 2;\n\n    const effect = this.document.createElement(\"span\");\n    setCSSProperties(effect, {\n      \"display\": \"block\",\n      \"background-color\": \"currentColor\",\n      \"position\": \"absolute\",\n      \"left\": x + \"px\",\n      \"top\": y + \"px\",\n      \"width\": size + \"px\",\n      \"height\": size + \"px\",\n      \"border-radius\": \"50%\",\n      \"opacity\": \"0\",\n      \"transform\": \"translate(-50%, -50%) scale(0)\",\n      \"transition\": `transform ${this.options.duration}ms ${this.options.easing} 0ms, opacity 0ms linear 0ms`,\n    });\n\n    const exit = () => {\n      effect.style.transitionDuration = `${this.options.duration}ms, ${this.options.duration / 2}ms`;\n      effect.style.opacity = \"0\";\n\n      setTimeout(() => {\n        effect.remove();\n      }, this.options.duration);\n    };\n\n    await waitAnimationFrame();\n    this.wrapper.append(effect);\n\n    await waitAnimationFrame();\n    effect.style.opacity = this.options.pressedOpacity + \"\";\n    effect.style.transform = \"translate(-50%, -50%) scale(1)\";\n\n    window.setTimeout(() => {\n      if (typeof exitFn === \"function\") {\n        exitFn(exit);\n      } else {\n        exit();\n      }\n    }, this.options.duration + this.options.exitdelay);\n  }\n\n  destroy() {\n    this._destroy_tasks.forEach((task) => task.call(this));\n    delete this.target[`__${uniqueID}_RippleEffect`];\n  }\n\n  /**\n   * @param {HTMLElement} target\n   * @param {RippleEffectOptions} options\n   * @return {RippleEffect}\n   */\n  static attachTo(target, options) {\n    if (!(target[`__${uniqueID}_RippleEffect`] instanceof RippleEffect)) {\n      return (target[`__${uniqueID}_RippleEffect`] = new RippleEffect(\n        target,\n        options,\n      ));\n    }\n    return target[`__${uniqueID}_RippleEffect`];\n  }\n\n  /** @type {RippleEffectOptions} */\n  static defaultOptions = {\n    color: \"currentColor\",\n    duration: 400,\n    unbounded: false,\n    autoexit: true,\n    exitdelay: 0,\n    centered: false,\n    rounded: false,\n    easing: \"ease-in\",\n    keydown: true,\n    hoveredOpacity: 0.08,\n    focusedOpacity: 0.08,\n    pressedOpacity: 0.12,\n  };\n}\n\nlet isTouchscreen = false;\n\nif (typeof window == \"object\") {\n  Object.defineProperty(window, \"RippleEffect\", {\n    value: RippleEffect,\n    configurable: true,\n    enumerable: false,\n    writable: true,\n  });\n  window.addEventListener(\n    \"touchstart\",\n    () => {\n      isTouchscreen = true;\n    },\n    { once: true },\n  );\n}\n", "export class FlexyBaseComponent {\n  private destroyTasks = new Set<() => void>();\n\n  constructor(readonly host: HTMLElement) {}\n\n  addDestroyTasks(task: () => void) {\n    this.destroyTasks.add(task);\n  }\n\n  destroy() {\n    this.destroyTasks.forEach((task) => task());\n    this.destroyTasks.clear();\n  }\n}\n", "import RippleEffect from '@nureon22/ripple-effect';\nimport { FlexyBaseComponent } from '../base';\n\nexport class FlexyButtonComponent extends FlexyBaseComponent {\n  constructor(host: HTMLElement) {\n    super(host);\n\n    const ripple = RippleEffect.attachTo(host, {\n      duration: 250,\n      exitdelay: 150,\n      hoveredOpacity: 0.12,\n      focusedOpacity: 0,\n      pressedOpacity: 0.12,\n      keydown: false,\n    });\n    this.addDestroyTasks(() => ripple.destroy());\n  }\n}\n", "import { FlexyBaseComponent } from '../base';\n\nexport class FlexySwitchComponent extends FlexyBaseComponent {\n  readonly input: HTMLInputElement | null = this.host.querySelector('input');\n\n  constructor(host: HTMLElement) {\n    super(host);\n  }\n}\n", "import { FlexyButtonComponent } from './components/button';\nimport { FlexySwitchComponent } from './components/switch';\n\ndocument.querySelectorAll('.flexy-button').forEach((el) => {\n  if (el instanceof HTMLElement) {\n    new FlexyButtonComponent(el);\n  }\n});\ndocument.querySelectorAll('.flexy-switch').forEach((el) => {\n  if (el instanceof HTMLElement) {\n    new FlexySwitchComponent(el);\n  }\n});\n"],
  "mappings": "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",
  "names": ["uniqueID", "waitAnimationFrame", "resolve", "setCSSProperties", "element", "properties", "key", "_RippleEffect", "target", "options", "__publicField", "hoveredAndFocusedLayerStyles", "targetCSSPosition", "onKeyDown", "event", "pressing", "x", "y", "rect", "exit", "e", "onTouch", "isMouseEvent", "isTouchscreen", "onHover", "isHovered", "onFocusChange", "isFocused", "trigger", "exitFn", "size", "effect", "task", "RippleEffect", "FlexyBaseComponent", "host", "task", "FlexyButtonComponent", "FlexyBaseComponent", "host", "ripple", "RippleEffect", "FlexySwitchComponent", "FlexyBaseComponent", "host", "el", "FlexyButtonComponent", "FlexySwitchComponent"]
}
